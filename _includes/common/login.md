This chapter is about means to protect your application from anonymous users who could deliberately
delete random data or pollute your application with spam messages. Until now, your application was publicly
available to online audience without any possibility to control who is working with stored data.
I want to show you how to store user account data securely (especially passwords) and how to verify
(authenticate) a user which is trying to log into your application. I will not talk about different levels
of user permissions because it would complicate things a lot -- such feature is called authorisation.

## Storing users' passwords
It is not a safe approach to store passwords in their plain-text form. Such passwords can be viewed by anybody
who has access to your database (maybe now it is only you, but in future it can be some of your colleagues or
even your employees). A password is always saved in hashed form (a *hash* is a result of function which outputs
a unique strings for different inputs and it is not trivial to reverse this process -- i.e. to calculate original
password from a hash).

Examples of hash function outputs in PHP for word "cat":

- [md5](http://php.net/manual/en/function.md5.php)('cat') =
  d077f244def8a70e5ea758bd8352fcd8 (always 32 characters)
- [sha1](http://php.net/manual/en/function.sha1.php)('cat') =
  9d989e8d27dc9e0ec3389fc855f142c3d40f0c50 (always 40 characters)
- [password_hash](http://php.net/manual/en/function.password-hash.php)('cat') =
  $2y$10$5iA8dvLAzWzl.cepri1xxuINCQBHKNANmEfx4nT/jjCV4hWcUTW.y (up to 255 characters according to selected hashing algorithm)

{: .note}
Function `password_hash()` is a bit different because its output is not always same like with the md5 or
sha1 functions. It is caused by a *salt* which is a sequence of random characters. The *salt* is used to make
hashes unique to avoid attackers from searching hashes online or using vocabulary attacks (try to
search for md5 hash **e246c559bf94965d89cf207fc45905bc** using [Google](http://www.google.com?q=e246c559bf94965d89cf207fc45905bc) --
[d'oh](https://en.wikipedia.org/wiki/D'oh!)). A salt is stored directly in the result of `password_hash()` function.
To verify a password generated by `password_hash()` use [password_verify()](http://php.net/manual/en/function.password-verify.php)
function.

{: .note.note-cont}
You can also use a salt with the md5 or sha1 but you have to handle it by yourself (you will need another column in
your database table to store it).

It is impossible to show/send user his original forgotten password due to hashing (but the security benefits of hashing
are more significant). If you need to have the ability of self managed passwords restoring in your application, you
should send a new password to email specified during registration process. You can use [PHP's `mail()` function](https://www.php.net/manual/en/function.mail.php).
Even better way is to send unique password reset request link to his email, so the password is in fact restored
only when the user clicks this link from his email account.

{: .note}
This makes the email address of a user also a very sensitive information. Change of an email address should only be
possible after confirmation of ownership of current email address -- send unique token to his current email address
to authorize changes. 

### Task -- try to calculate hash with random salt and verify it
To store a password during registration process:

    hash = sha1(randomSalt + registrationPassword)

To verify a password when user tries to log-in (first fetch hash and salt from database):

    if(sha1(databaseSalt + providedPassword) == databaseHash) {...OK...}

{: .solution}
{% highlight php %}
{% include /common/login/hash-salt.php %}
{% endhighlight %}

{: .note}
The probability that concatenation of user's password and a random string used as a salt
will yield results in vocabulary search is very small. Yet use of `sha1()` or `md5()` functions
is strongly discouraged because powerful CPUs or GPUs can generate millions of hashes per second and
they are capable of breaking md5 or sha1 hashes within reasonable time (days). Recommended function
`password_hash()` is also quite slow (by design -- this is one of few instances when we want our
algorithms to be slow).

{: .note}
One of the reasons why any web application sends you a new password instead of yours when you forgot
it, is hashing. They do not store your password in plain text form.

### Task -- create a table to store user data in database
Create a table with login or email column and a column to store password in hashed format.
If you plan to use `password_hash()` function, you do not need another column for salt.
Remember that login or email column must have unique constraint to prevent duplicate user accounts.

For PostgreSQL:

{: .solution}
{% highlight sql %}
{% include /common/login/pgsql-account-table.sql %}
{% endhighlight %}

For MySQL:

{: .solution}
{% highlight sql %}
{% include /common/login/mysql-account-table.sql %}
{% endhighlight %}

## Registration process
Registration is actually not very much different from any other record insertion. Only difference is
that you have to validate match of the passwords and calculate the hash. After successful insertion of
the account record redirect the visitor to the login page.